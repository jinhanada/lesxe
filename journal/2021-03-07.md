# 2021-03-07

## GCのバグ

ひとつやっつけた。

結論から言うと、案の定VM用stackのPush/Popをミスって古いポインタを参照していた。

ただ、その間違い方が少し特殊だった。applyFuncの中で起きたんだけど、次のようなコードが原因だった。

```c
Func f = func->Func;
Obj hoge = f.code;

// ...

Push(func); // あれ、fは？

// ...GCが起きる処理...


func = Pop(); // funcは更新されたけど……

// ...

foobar(f.code); // ここで古いfunc->Funcを使って落ちる
```

毎回`func->Func.code`というように参照したら長いので、`f = func->Func`と変数に入れて使っていたらそっちの方のPush/Popを忘れていた。

struct Funcはスタックに入れられないし、Push/Popするものやその前後の処理が増えると危険なので、おとなしく`func->Func.code`みたいに書いておく。

他にも同じミスをしているところがないか、軽く見ておいた。

特定までもなかなか長かった。lispコードの方からどういう処理の最中に落ちているのか調べていたけど、偶然絞り込みに間違えたところにprintを挿入して起きたことで、根本的なapply周りがあやしいと気づいた。

次やるときはlispコードの方からではなく、インタプリタのeval分岐から絞り込んだ方が良いと思う。