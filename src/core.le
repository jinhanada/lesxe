(def list (fn xs xs))
(def else true)

(def +   (fn (a b) (%prim:add a b)))
(def -   (fn (a b) (%prim:sub a b)))
(def *   (fn (a b) (%prim:mul a b)))
(def /   (fn (a b) (%prim:div a b)))
(def mod (fn (a b) (%prim:mod a b)))
(def inc (fn (n)   (%prim:add n 1)))
(def dec (fn (n)   (%prim:sub n 1)))

(def =   (fn (a b) (%prim:eq a b)))
(def not (fn (x)   (%prim:not x)))

(def >  (fn (a b) (%prim:gt a b)))
(def >= (fn (a b) (if (= a b) true (> a b))))
(def <  (fn (a b) (not (>= a b))))
(def <= (fn (a b) (not (> a b))))

(def neg (fn (n) (- 0 n)))
(def abs (fn (n) (if (> 0 n) (neg n) n)))


;; types
;; =====================================
(def type-of
     (fn (x) (%prim:type-of x)))
(def nil?     (fn (x) (not x)))
(def number?  (fn (x) (= (type-of x) 'number)))
(def array?   (fn (x) (= (type-of x) 'array)))
(def symbol?  (fn (x) (= (type-of x) 'symbol)))
(def pair?    (fn (x) (= (type-of x) 'pair)))
(def func?    (fn (x) (= (type-of x) 'func)))
(def bytes?   (fn (x) (= (type-of x) 'bytes)))
(def string?  (fn (x) (= (type-of x) 'string)))

(def hash-of
     (fn (x) (%prim:hash x)))


;; error
;; =====================================

(def raise
     (fn (error) (%prim:raise error)))


;; array
;; =====================================
(def array:new  (fn (n)      (%prim:array-new n)))
(def array:get  (fn (xs i)   (%prim:array-get xs i)))
(def array:set! (fn (xs i v) (%prim:array-set! xs i v)))
(def array:len  (fn (xs)     (%prim:array-len xs)))


;; pair
;; =====================================
(def cons     (fn (a b) (%prim:cons a b)))
(def car      (fn (xs) (%prim:car xs)))
(def cdr      (fn (xs) (%prim:cdr xs)))
(def set-car! (fn (xs v) (%prim:set-car! xs v)))
(def set-cdr! (fn (xs v) (%prim:set-cdr! xs v)))

(def caar (fn (xs) (car (car xs))))
(def cadr (fn (xs) (car (cdr xs))))
(def cdar (fn (xs) (cdr (car xs))))
(def cddr (fn (xs) (cdr (cdr xs))))

(def second (fn (xs) (car (cdr xs))))
(def third  (fn (xs) (car (cdr (cdr xs)))))


(def list:each
     (fn (xs f)
       (if xs
         (let ()
           (f (car xs))
           (list:each (cdr xs) f))
         xs)))

(def list:len
     (fn (xs)
       (let ((len 0))
         (list:each xs (fn (_) (set! len (+ len 1))))
         len)))

(def list:map
     (fn (xs f)
       (if xs
           (cons (f (car xs))
                 (list:map (cdr xs) f))
           nil)))

(def list:concat
     (fn (xs ys)
       (if xs
           (cons (car xs) (list:concat (cdr xs) ys))
           ys)))


;; ===== assoc (mutable) =====

(def assoc:sign '<assoc>)

(def assoc:new
     (fn args
       (let ((rec nil))
         (set! rec
               (fn (xs acc)
                 (if xs
                   (rec (cddr xs)
                        (cons (cons (car xs) (second xs)) acc))
                   (cons assoc:sign acc))))
         (rec args nil))))

(def assoc:ref
     (fn (assoc key)
       (let ((rec nil))
         (set! rec
               (fn (xs)
                 (if xs
                   (let ((x (car xs)))
                     (if (= (car x) key)
                       x
                       (rec (cdr xs)))))))
         (rec (cdr assoc)))))

(def assoc:get
     (fn (assoc key)
       (cdr (assoc:ref assoc key))))

(def assoc:set!
     (fn (assoc key val)
       (let ((ref (assoc:ref assoc key)))
         (if ref
             (set-cdr! ref val)
             (set-cdr! assoc (cons (cons key val)
                                   (cdr assoc)))))
       assoc))


;; ===== dict (mutable hash table) =====

(def dict:sign '<dict>)
(def dict:default-size 63)

(def dict:aux:index
     (fn (xs key)
       (let ((len  (array:len xs))
             (hash (hash-of key)))
         (mod (abs hash) len))))

(def dict:aux:entry
     (fn (dict key)
       (let ((xs   (second dict))
             (i    (dict:aux:index xs key)))
         (array:get xs i))))

(def dict:aux:set
     (fn (xs key val)
       (let ((i     (dict:aux:index xs key))
             (assoc (array:get xs i)))
         (if assoc
             (assoc:set! assoc key val)
             (array:set! xs i (assoc:new key val))))))

(def dict:new
     (fn args
       (let ((rec nil)
             (len dict:default-size)
             (xs (array:new len)))
         (set! rec
               (fn (args)
                 (if args
                   (let ()
                     (dict:aux:set xs (car args) (second args))
                     (rec (cdr args))))))
         (rec args)
         (list dict:sign xs))))

(def dict:has?
     (fn (dict key)
       (if (dict:aux:entry dict key) true nil)))

(def dict:get
     (fn (dict key)
       (let ((assoc (dict:aux:entry dict key)))
         (assoc:get assoc key))))

(def dict:set!
     (fn (dict key val)
       (let ((xs (second dict)))
         (dict:aux:set xs key val)
         dict)))


;; symbol
;; =====================================

(def sym:new
     (fn (str) (%prim:sym-new str)))

(def sym:str
     (fn (sym) (%prim:sym-str sym)))


;; string
;; =====================================

(def strfy (fn (s) (%prim:str s)))
(def str= (fn (a b) (%prim:str-eq a b)))
(def str:get (fn (s i) (%prim:str-get s i)))
(def str:len (fn (s) (%prim:str-len s)))
(def str:cat (fn (xs) (%prim:str-cat xs)))
(def str:sub (fn (s start end) (%prim:str-sub s start end)))
(def str:index (fn (s what) (%prim:str-index s what)))
(def str:make
     ;; arrayofchars -> string
     (fn (xs) (%prim:str-make xs)))

(def str
     (fn args
       (%prim:str-cat
        (list:map args (fn (x) (if (string? x) x (strfy x)))))))



;; bytes
;; =====================================

(def bytes:new  (fn (n)      (%prim:bytes-new n)))
(def bytes:get  (fn (xs i)   (%prim:bytes-get xs i)))
(def bytes:set! (fn (xs i v) (%prim:bytes-set! xs i v)))
(def bytes:len  (fn (xs)     (%prim:bytes-len xs)))


;; read
;; =====================================

(def read:str (fn (s) (%prim:read-str s)))


;; i/o
;; =====================================

(def fd-stdin  0)
(def fd-stdout 1)
(def fd-stderr 2)

(def io:getc
     (fn (fd) (%prim:getc fd)))

(def io:putc
     (fn (fd c) (%prim:putc fd c)))

(def getc
     (fn () (%prim:getc fd-stdin)))

(def putc
     (fn (c) (%prim:putc fd-stdout c)))

(def c:newline 10)

(def newline
     (fn () (putc c:newline)))

(def c:space 32)

(def space
     (fn () (putc c:space)))

(def io:print
     (fn (fd s) (%prim:print fd s)))

(def prin1
     (fn (x)
       (io:print fd-stdout (str x))
       x))

(def print
     (fn (x)
       (prin1 x)
       (newline)
       x))

(def prn
     (fn args
       (list:each args (fn (x) (prin1 x) (space)))
       (newline)
       (car args)))

(def file:read-text
     (fn (fname)
       (%prim:read-text-file fname)))

(def file:write-text
     (fn (fname str)
       (%prim:write-text-file fname str)))


;; network
;; =====================================
(def sock:make   (fn (port) (%prim:socket-make port)))
(def sock:listen (fn (sockfd limit) (%prim:socket-listen sockfd limit)))
(def sock:send   (fn (sockfd str) (%prim:socket-send sockfd str)))
(def sock:accept (fn (sockfd ) (%prim:socket-accept sockfd)))
(def sock:recv   (fn (sockfd limit) (%prim:socket-recv sockfd limit)))
(def sock:close  (fn (sockfd) (%prim:socket-close sockfd)))


;; macro system
;; =====================================

(def macro:syntax-dict (dict:new))
(def macro:macro-dict (dict:new))
(def macro:debug nil)

(def expand-macro-1 nil) ;; for recursion


;; ===== syntax =====

(def macro:aux-rec
     (fn (counter)
       (fn (expr)
         (expand-macro-1 counter expr))))

(dict:set!
 macro:syntax-dict
 'let
 (fn (counter expr)
   (let ((binds (car expr))
         (body  (cdr expr))
         (f (macro:aux-rec counter))
         (binds (list:map binds (fn (x) (list (car x) (f (second x))))))
         (body (list:map body f)))
     (cons 'let (cons binds body)))))

(dict:set!
 macro:syntax-dict
 'if
 (fn (counter expr)
   (let ((f    (macro:aux-rec counter))
         (cond (f (car expr)))
         (then (f (second expr)))
         (else (f (third expr))))
     (list 'if cond then else))))

(dict:set!
 macro:syntax-dict
 'set!
 (fn (counter expr)
   (let ((f   (macro:aux-rec counter))
         (var (car expr))
         (val (f (second expr))))
     (list 'set! var val))))

(dict:set!
 macro:syntax-dict
 'fn
 (fn (counter expr)
   (let ((f    (macro:aux-rec counter))
         (vars (car expr))
         (body (list:map (cdr expr) f)))
     (cons 'fn (cons vars body)))))

(dict:set!
 macro:syntax-dict
 'def
 (fn (counter expr)
   (let ((f   (macro:aux-rec counter))
         (var (car expr))
         (val (f (second expr))))
     (list 'def var val))))

(dict:set!
 macro:syntax-dict
 'quote
 (fn (counter expr)
   (cons 'quote expr)))

(dict:set!
 macro:syntax-dict
 'apply
 (fn (counter expr)
   (let ((f (macro:aux-rec counter)))
     (list 'apply
           (f (car expr))
           (f (second expr))))))

(dict:set!
 macro:syntax-dict
 'catch
 (fn (counter expr)
   (let ((f (macro:aux-rec counter)))
     (list 'catch
           (f (car expr))
           (f (second expr))))))


;; ===== demac =====

(dict:set!
 macro:macro-dict
 'demac
 (fn (def . body)
   ;; (demacro (name . args) . body)
   ;; => (dict:set! macro:macro-dict (quote . name) (fn args . body))
   (let ((name (car def))
         (args (cdr def)))
     (list 'dict:set! 'macro:macro-dict
           (cons 'quote name)
           (cons 'fn (cons args body))))))


;; ===== expand =====

(set! expand-macro-1
      (fn (counter expr)
        (if (pair? expr)
            (let ((x  (car expr))
                  (xs (cdr expr))
                  (syntax (dict:get macro:syntax-dict x))
                  (macro  (dict:get macro:macro-dict x)))
              (if syntax
                  (syntax counter xs)
                  (if macro
                      (let ()
                        (counter)
                        (apply macro xs))
                      (cons (expand-macro-1 counter x)
                            (list:map xs (fn (x) (expand-macro-1 counter x)))))))
            expr)))

(def expand-macro
     (fn (expr)
       (let ((count 1)
             (counter (fn () (set! count (+ count 1))))
             (loop nil))
         (set! loop
               (fn (expr)
                 (if (> count 0)
                   (let ()
                     (set! count 0)
                     (loop (expand-macro-1 counter expr)))
                   expr)))
         (loop expr))))

(set! %pre-eval
      (fn (expr)
        (let ((expanded (expand-macro expr)))
          (if macro:debug (print (list 'expanded expanded)))
          expanded)))


;; macros
;; =====================================

(demac (and . xs)
  (let ((rec nil))
    (set! rec
          (fn (xs)
            (if xs
                (list 'if (car xs) (cons 'and (cdr xs)) nil)
                true)))
    (rec xs)))

(demac (or . xs)
  (let ((rec nil))
    (set! rec
          (fn (xs)
            (if xs
                (list 'if (car xs) true (cons 'or (cdr xs)))
                nil)))
    (rec xs)))


;; simple quasiquote expander
;; do not nest.
(demac (quasiquote . expr)
  (let ((qq-object nil)
        (qq-pair nil)
        (qq-list nil))
    (set!
     qq-object
     (fn (x)
       (if (pair? x)
           (qq-list x)
           (cons 'quote x))))
    (set!
     qq-pair
     (fn (xs)
       (if (= (car xs) 'unquote)
           (cdr xs)
           (qq-list xs))))
    (set!
     qq-list
     (fn (xs)
       (if (pair? xs)
           (let ((f    (car xs))
                 (rest (cdr xs)))
             (if (= f 'unquote)
                 ;; xs: (unquote . rest)
                 rest
                 (if (and (pair? f)
                          (= (car f) 'unquote-splicing))
                     ;; xs: ((unquote-splicing . x) . rest)
                     (list 'list:concat (cdr f) (qq-list rest))
                     (list 'cons (qq-object f) (qq-list rest)))))
           (cons 'quote xs))))
    (qq-object expr)))


(demac (letrec binds . body)
  ;; (letrec ((f fn) ...) . body)
  ;; => (let ((f nil)) (set! f fn) . body)
  (let ((defs (list:map binds (fn (x) `(,(car x) nil))))
        (sets (list:map binds (fn (x) `(set! ,(car x) ,(second x))))))
    `(let ,defs ,@sets ,@body)))


(demac (loop name binds . body)
  ;; (loop name ((var val) ...) . body)
  ;; => (letrec ((name (fn (var ...) . body))) (name val ...))
  (let ((vars (list:map binds car))
        (vals (list:map binds second)))
    `(letrec ((,name (fn ,vars ,@body))) (,name ,@vals))))


(demac (when cond . body)
  `(if ,cond (let () ,@body)))

(demac (unless cond . body)
  `(if ,cond nil (let () ,@body)))


(demac (push! xs x)
  `(set! ,xs (cons ,x ,xs)))


(demac (de defi . body)
  (if (pair? defi)
    (let ((name  (car defi))
          (args  (cdr defi))
          ;; collect internal defines
          (letrec-binds  nil)
          (rest-body     nil))
      (loop collect ((body body))
        (when body
          (let ((expr  (car body))
                (rest (cdr body)))
            (if (= 'de (car expr))
              (let ()
                (let ((defi (second expr))
                      (name (car defi))
                      (args (cdr defi))
                      (body (cddr expr)))
                  (push! letrec-binds (list name `(fn ,args ,@body))))
                (collect rest))
              (set! rest-body body)))))
      (let ((f (if letrec-binds
                 `(fn ,args (letrec ,letrec-binds ,@rest-body))
                 `(fn ,args ,@rest-body))))
        `(def ,name ,f)))
    `(def ,defi ,(car body))))


(demac (cond clause . clauses)
  (loop rec ((clause clause) (clauses clauses))
    (let ((cond (car clause))
          (body (cdr clause))
          (rest (if clauses (rec (car clauses) (cdr clauses)) nil)))
      `(if ,cond (let () ,@body) ,rest))))


;; gensym
;; =====================================
(def sym:gensym-counter
     (let ((i 0))
       (fn () (set! i (+ i 1)))))

(de (sym:gen)
  (sym:new (str "#g:" (sym:gensym-counter))))


;; system
;; =====================================

(de (exit code)
  (%prim:exit (if code code 0)))

(de (sys:gc)
  (%prim:gc))

(de (sys:load fname)
  (%prim:load-file fname))

(de (sys:load-files files)
  (list:each files sys:load))


;; array 2
;; =====================================

(de (array:each xs f)
  (let ((len (array:len xs)))
    (loop rec ((i 0))
      (when (> len i)
        (f (array:get xs i) i)
        (rec (inc i))))
    xs))

(de (array:each-back xs f)
  (loop rec ((i (dec (array:len xs))))
    (when (> i -1)
      (f (array:get xs i) i)
      (rec (dec i))))
  xs)

(de (array:list xs)
  (let ((acc nil))
    (array:each-back xs (fn (x) (set! acc (cons x acc))))
    acc))


;; bytes 2
;; =====================================

(de (bytes:each xs f)
  (let ((len (bytes:len xs)))
    (loop rec ((i 0))
      (when (> len i)
        (f (bytes:get xs i) i)
        (rec (inc i))))
    xs))

(de (bytes:each-back xs f)
  (loop rec ((i (dec (bytes:len xs))))
    (when (> i -1)
      (f (bytes:get xs i) i)
      (rec (dec i))))
  xs)

(de (bytes:list xs)
  (let ((acc nil))
    (bytes:each-back xs (fn (x) (set! acc (cons x acc))))
    acc))


;; pair 2
;; =====================================

(de (list:reverse! xs)
  ;; in-place
  (let ((last nil)
        (next nil))
    (loop rec ((xs xs))
      (when xs
        (set! next (cdr xs))
        (set-cdr! xs last)
        (set! last xs)
        (rec next)))
    last))

(de (list:reverse xs)
  (loop rec ((xs xs) (acc nil))
    (if xs
      (rec (cdr xs) (cons (car xs) acc))
      acc)))

(de (list:cons* x . xs)
  ;; (cons* 1 2 3) => (1 2 . 3)
  ;; (cons* 1 2 '(3 4)) => (1 2 3 4)
  (if xs
      (if (and (pair? (car xs)) (not (cdr xs)))
          (cons x (car xs))
          (cons x (apply list:cons* xs)))
      x))


;; string 2
;; =====================================

(de (str:chars s)
  (let ((len (str:len s))
        (xs  (array:new len)))
    (loop rec ((i 0))
      (when (> len i)
        (array:set! xs i (str:get s i))
        (rec (inc i))))
    xs))

(de (str:split1 src what)
  ;; nil | (former . latter)
  (let ((slen (str:len src))
        (wlen (str:len what))
        (i    (str:index src what)))
    (if (nil? i) nil
        (cons (str:sub src 0 i)
              (let ((next (+ i wlen)))
                (if (>= next slen)
                    ""
                    (str:sub src next slen)))))))

(de (str:split src what)
  ;; (list of splitted strings)
  (loop rec ((acc nil) (src src))
    (let ((s (str:split1 src what)))
      (if s
          (rec (cons (car s) acc)
               (cdr s))
          (list:reverse! (cons src acc))))))

(de (str:join xs what)
  ;; (list of string) => "listwhatofwhatstring"
  (loop rec ((x (car xs)) (xs (cdr xs)))
    (if xs
      (str x what (rec (car xs) (cdr xs)))
      (str x))))


;; record-case
;; =====================================
;; (record-case (list 'foo 1 2)
;;   ((foo a b) (+ a b))
;;   (else ...))

(demac (record-case record . clauses)
  (let ((xs   (sym:gen))
        (sign (sym:gen))
        (vals (sym:gen))
        (expanded
         (loop expand ((cs clauses))
           (if cs
             (let ((clause (car cs))
                   (rest   (expand (cdr cs)))
                   (match  (car clause))
                   (body   (cdr clause)))
               (if (= match 'else)
                 `(let () ,@body)
                 (let ((op     (car match))
                       (binds  (cdr match)))
                   `(if (= ,sign ',op)
                      (apply (fn ,binds ,@body) ,vals)
                      ,rest))))
             `(raise (list 'record-unmatched ,xs))))))
    `(let ((,xs   ,record)
           (,sign (car ,xs))
           (,vals (cdr ,xs)))
       ,expanded)))


;; threading macros
;; =====================================
(demac (-> arg f . rest)
  (loop rec ((arg arg) (f f) (rest rest))
    (let ((wrapped
           (cond
            ((symbol? f) (list f arg))
            ((pair? f)   `(,(car f) ,arg ,@(cdr f)))
            (else        (raise `(in -> ,f should be symbol or pair))))))
      (if rest
        (rec wrapped (car rest) (cdr rest))
        wrapped))))
