(def list (fn Xs Xs))

(def +   (fn (A B) (%prim:add A B)))
(def -   (fn (A B) (%prim:sub A B)))
(def *   (fn (A B) (%prim:mul A B)))
(def /   (fn (A B) (%prim:div A B)))
(def mod (fn (A B) (%prim:mod A B)))

(def =   (fn (A B) (%prim:eq A B)))
(def not (fn (X)   (%prim:not X)))

(def >  (fn (A B) (%prim:gt A B)))
(def >= (fn (A B) (if (= A B) true (> A B))))
(def <  (fn (A B) (not (>= A B))))
(def <= (fn (A B) (not (> A B))))

(def neg (fn (N) (- 0 N)))
(def abs (fn (N) (if (> 0 N) (neg N) N)))


;; Types
;; =====================================
(def type-of
     (fn (X) (%prim:type-of X)))
(def nil?     (fn (X) (not X)))
(def number?  (fn (X) (= (type-of X) 'number)))
(def array?   (fn (X) (= (type-of X) 'array)))
(def symbol?  (fn (X) (= (type-of X) 'symbol)))
(def pair?    (fn (X) (= (type-of X) 'pair)))
(def func?    (fn (X) (= (type-of X) 'func)))
(def bytes?   (fn (X) (= (type-of X) 'bytes)))
(def string?  (fn (X) (= (type-of X) 'string)))

(def hash-of
     (fn (X) (%prim:hash X)))


;; Error
;; =====================================

(def raise
     (fn (Error) (%prim:raise Error)))


;; Array
;; =====================================
(def array:new  (fn (N)      (%prim:array-new N)))
(def array:get  (fn (Xs I)   (%prim:array-get Xs I)))
(def array:set! (fn (Xs I V) (%prim:array-set! Xs I V)))
(def array:len  (fn (Xs)     (%prim:array-len Xs)))


;; Pair
;; =====================================
(def cons     (fn (A B) (%prim:cons A B)))
(def car      (fn (Xs) (%prim:car Xs)))
(def cdr      (fn (Xs) (%prim:cdr Xs)))
(def set-car! (fn (Xs V) (%prim:set-car! Xs V)))
(def set-cdr! (fn (Xs V) (%prim:set-cdr! Xs V)))

(def cadr (fn (Xs) (car (cdr Xs))))
(def cddr (fn (Xs) (cdr (cdr Xs))))

(def second (fn (Xs) (car (cdr Xs))))
(def third  (fn (Xs) (car (cdr (cdr Xs)))))


(def list:map
     (fn (Xs F)
       (if Xs
           (cons (F (car Xs))
                 (list:map (cdr Xs) F))
           nil)))

(def list:concat
     (fn (Xs Ys)
       (if Xs
           (cons (car Xs) (list:concat (cdr Xs) Ys))
           Ys)))


;; ===== Assoc (mutable) =====

(def assoc:sign '<Assoc>)

(def assoc:new
     (fn Args
       (let ((Xs Args) (Acc nil))
         (while Xs
                (set! Acc (cons (cons (car Xs) (second Xs))
                                Acc))
                (set! Xs (cddr Xs)))
         (cons assoc:sign Acc))))

(def assoc:ref
     (fn (Assoc Key)
       (let ((Xs (cdr Assoc)) (R nil))
         (while Xs
                (let ((X (car Xs)))
                  (if (= (car X) Key)
                      (let ()
                        (set! R X)
                        (set! Xs nil))
                      (set! Xs (cdr Xs)))))
         R)))

(def assoc:get
     (fn (Assoc Key)
       (cdr (assoc:ref Assoc Key))))

(def assoc:set!
     (fn (Assoc Key Val)
       (let ((Ref (assoc:ref Assoc Key)))
         (if Ref
             (set-cdr! Ref Val)
             (set-cdr! Assoc (cons (cons Key Val)
                                   (cdr Assoc)))))
       Assoc))


;; ===== Dict (mutable hash table) =====

(def dict:sign '<Dict>)
(def dict:default-size 63)

(def dict:aux:index
     (fn (Xs Key)
       (let ((Len  (array:len Xs))
             (Hash (hash-of Key)))
         (mod (abs Hash) Len))))

(def dict:aux:entry
     (fn (Dict Key)
       (let ((Xs   (second Dict))
             (I    (dict:aux:index Xs Key)))
         (array:get Xs I))))

(def dict:aux:set
     (fn (Xs Key Val)
       (let ((I     (dict:aux:index Xs Key))
             (Assoc (array:get Xs I)))
         (if Assoc
             (assoc:set! Assoc Key Val)
             (array:set! Xs I (assoc:new Key Val))))))

(def dict:new
     (fn Args
       (let ((Args Args)
             (Len dict:default-size)
             (Xs (array:new Len)))
         (while Args
                (dict:aux:set Xs (car Args) (second Args))
                (set! Args (cddr Args)))
         (list dict:sign Xs))))

(def dict:has?
     (fn (Dict Key)
       (if (dict:aux:entry Dict Key) true nil)))

(def dict:get
     (fn (Dict Key)
       (let ((Assoc (dict:aux:entry Dict Key)))
         (assoc:get Assoc Key))))

(def dict:set!
     (fn (Dict Key Val)
       (let ((Xs (second Dict)))
         (dict:aux:set Xs Key Val)
         Dict)))


;; Symbol
;; =====================================

(def sym:new
     (fn (Str) (%prim:sym-new Str)))

(def sym:str
     (fn (Sym) (%prim:sym-str Sym)))


;; String
;; =====================================

(def strfy (fn (S) (%prim:str S)))

(def str:get (fn (S I) (%prim:str-get S I)))

(def str:len (fn (S) (%prim:str-len S)))

(def str:make
     ;; ArrayOfChars -> String
     (fn (Xs) (%prim:str-make Xs)))

(def str:cat
     (fn (Xs) (%prim:str-cat Xs)))

(def str
     (fn Args
       (%prim:str-cat
        (list:map Args (fn (X) (if (string? X) X (strfy X)))))))

(def str=
     (fn (A B) (%prim:str-eq A B)))


;; Bytes
;; =====================================

(def bytes:new  (fn (N)      (%prim:bytes-new N)))
(def bytes:get  (fn (Xs I)   (%prim:bytes-get Xs I)))
(def bytes:set! (fn (Xs I V) (%prim:bytes-set! Xs I V)))
(def bytes:len  (fn (Xs)     (%prim:bytes-len Xs)))


;; Read
;; =====================================

(def read:str (fn (S) (%prim:read-str S)))


;; I/O
;; =====================================

(def FD-STDIN  0)
(def FD-STDOUT 1)
(def FD-STDERR 2)

(def io:getc
     (fn (FD) (%prim:getc FD)))

(def io:putc
     (fn (FD C) (%prim:putc FD C)))

(def getc
     (fn () (%prim:getc FD-STDIN)))

(def putc
     (fn (C) (%prim:putc FD-STDOUT C)))

(def c:newline 10)

(def newline
     (fn () (putc c:newline)))

(def io:print
     (fn (FD S) (%prim:print FD S)))

(def prin1
     (fn (X)
       (io:print FD-STDOUT (str X))
       X))

(def print
     (fn (X)
       (prin1 X)
       (newline)
       X))

(def file:read-text
     (fn (FName)
       (%prim:read-text-file FName)))

(def file:write-text
     (fn (FName Str)
       (%prim:write-text-file FName Str)))


;; Macro System
;; =====================================

(def macro:SYNTAX-DICT (dict:new))
(def macro:MACRO-DICT (dict:new))
(def macro:DEBUG nil)

(def expand-macro-1 nil) ;; for recursion


;; ===== Syntax =====

(def macro:aux-rec
     (fn (Counter)
       (fn (Expr)
         (expand-macro-1 Counter Expr))))

(dict:set!
 macro:SYNTAX-DICT
 'let
 (fn (Counter Expr)
   (let ((Binds (car Expr))
         (Body  (cdr Expr))
         (F (macro:aux-rec Counter))
         (Binds (list:map Binds (fn (X) (list (car X) (F (second X))))))
         (Body (list:map Body F)))
     (cons 'let (cons Binds Body)))))

(dict:set!
 macro:SYNTAX-DICT
 'if
 (fn (Counter Expr)
   (let ((F    (macro:aux-rec Counter))
         (Cond (F (car Expr)))
         (Then (F (second Expr)))
         (Else (F (third Expr))))
     (list 'if Cond Then Else))))

(dict:set!
 macro:SYNTAX-DICT
 'while
 (fn (Counter Expr)
   (let ((F    (macro:aux-rec Counter))
         (Cond (F (car Expr)))
         (Body (list:map (cdr Expr) F)))
     (cons 'while (cons Cond Body)))))

(dict:set!
 macro:SYNTAX-DICT
 'break
 (fn (Counter _) (list 'break)))

(dict:set!
 macro:SYNTAX-DICT
 'continue
 (fn (Counter _) (list 'continue)))

(dict:set!
 macro:SYNTAX-DICT
 'set!
 (fn (Counter Expr)
   (let ((F   (macro:aux-rec Counter))
         (Var (car Expr))
         (Val (F (second Expr))))
     (list 'set! Var Val))))

(dict:set!
 macro:SYNTAX-DICT
 'fn
 (fn (Counter Expr)
   (let ((F    (macro:aux-rec Counter))
         (Vars (car Expr))
         (Body (list:map (cdr Expr) F)))
     (cons 'fn (cons Vars Body)))))

(dict:set!
 macro:SYNTAX-DICT
 'def
 (fn (Counter Expr)
   (let ((F   (macro:aux-rec Counter))
         (Var (car Expr))
         (Val (F (second Expr))))
     (list 'def Var Val))))

(dict:set!
 macro:SYNTAX-DICT
 'quote
 (fn (Counter Expr)
   (cons 'quote Expr)))

(dict:set!
 macro:SYNTAX-DICT
 'apply
 (fn (Counter Expr)
   (let ((F (macro:aux-rec Counter)))
     (list 'apply
           (F (car Expr))
           (F (second Expr))))))

(dict:set!
 macro:SYNTAX-DICT
 'catch
 (fn (Counter Expr)
   (let ((F (macro:aux-rec Counter)))
     (list 'catch
           (F (car Expr))
           (F (second Expr))))))


;; ===== demac =====

(dict:set!
 macro:MACRO-DICT
 'demac
 (fn (Def . Body)
   ;; (demacro (Name . Args) . Body)
   ;; => (dict:set! macro:MACRO-DICT (quote . Name) (fn Args . Body))
   (let ((Name (car Def))
         (Args (cdr Def)))
     (list 'dict:set! 'macro:MACRO-DICT
           (cons 'quote Name)
           (cons 'fn (cons Args Body))))))


;; ===== expand =====

(set! expand-macro-1
      (fn (Counter Expr)
        (if (pair? Expr)
            (let ((X  (car Expr))
                  (Xs (cdr Expr))
                  (Syntax (dict:get macro:SYNTAX-DICT X))
                  (Macro  (dict:get macro:MACRO-DICT X)))
              (if Syntax
                  (Syntax Counter Xs)
                  (if Macro
                      (let ()
                        (Counter)
                        (apply Macro Xs))
                      (cons (expand-macro-1 Counter X)
                            (list:map Xs (fn (X) (expand-macro-1 Counter X)))))))
            Expr)))

(def expand-macro
     (fn (Expr)
       (let ((X Expr)
             (Count 1)
             (Counter (fn () (set! Count (+ Count 1)))))
         (while (> Count 0)
                (set! Count 0)
                (set! X (expand-macro-1 Counter X)))
         X)))

(set! %pre-eval
      (fn (Expr)
        (let ((Expanded (expand-macro Expr)))
          (if macro:DEBUG (print (list 'expanded Expanded)))
          Expanded)))


;; Macros
;; =====================================

(demac (and . Xs)
  (let ((rec nil))
    (set! rec
          (fn (Xs)
            (if Xs
                (list 'if (car Xs) (cons 'and (cdr Xs)) nil)
                true)))
    (rec Xs)))

(demac (or . Xs)
  (let ((rec nil))
    (set! rec
          (fn (Xs)
            (if Xs
                (list 'if (car Xs) true (cons 'or (cdr Xs)))
                nil)))
    (rec Xs)))


;; Simple quasiquote expander
;; Do not nest.
(demac (quasiquote . Expr)
  (let ((qq-object nil)
        (qq-pair nil)
        (qq-list nil))
    (set!
     qq-object
     (fn (X)
       (if (pair? X)
           (qq-list X)
           (cons 'quote X))))
    (set!
     qq-pair
     (fn (Xs)
       (if (= (car Xs) 'unquote)
           (cdr Xs)
           (qq-list Xs))))
    (set!
     qq-list
     (fn (Xs)
       (if (pair? Xs)
           (let ((F    (car Xs))
                 (Rest (cdr Xs)))
             (if (= F 'unquote)
                 ;; Xs: (unquote . Rest)
                 Rest
                 (if (and (pair? F)
                          (= (car F) 'unquote-splicing))
                     ;; Xs: ((unquote-splicing . X) . Rest)
                     (list 'list:concat (cdr F) (qq-list Rest))
                     (list 'cons (qq-object F) (qq-list Rest)))))
           (cons 'quote Xs))))
    (qq-object Expr)))


(demac (letrec Binds . Body)
  ;; (letrec ((F Fn) ...) . Body)
  ;; => (let ((F nil)) (set! F Fn) . Body)
  (let ((Defs (list:map Binds (fn (X) `(,(car X) nil))))
        (Sets (list:map Binds (fn (X) `(set! ,(car X) ,(second X))))))
    `(let ,Defs ,@Sets ,@Body)))


(demac (de Def . Body)
  (let ((Name  (car Def))
        (Args  (cdr Def)))
    `(def ,Name ,(cons 'fn (cons Args Body)))))


;; Gensym
;; =====================================
(def sym:GENSYM-COUNTER
     (let ((I 0))
       (fn () (set! I (+ I 1)))))

(de (sym:gen)
  (sym:new (str "#g:" (sym:GENSYM-COUNTER))))


;; System
;; =====================================

(de (exit Code)
  (%prim:exit (if Code Code 0)))

(de (sys:gc)
  (%prim:gc))

(de (sys:load FName)
  (%prim:load-file FName))


;; Array 2
;; =====================================

(de (array:each Xs F)
  (let ((I   0)
        (Len (array:len Xs)))
    (while (> Len I)
      (F (array:get Xs I) I)
      (set! I (+ I 1)))
    Xs))

(de (array:each-back Xs F)
  (let ((Len (array:len Xs))
        (I   (- Len 1)))
    (while (> I -1)
      (F (array:get Xs I) I)
      (set! I (- I 1)))
    Xs))

(de (array:list Xs)
  (let ((Acc nil))
    (array:each-back Xs (fn (X) (set! Acc (cons X Acc))))
    Acc))


;; Bytes 2
;; =====================================

(de (bytes:each Xs F)
  (let ((I   0)
        (Len (bytes:len Xs)))
    (while (> Len I)
      (F (bytes:get Xs I) I)
      (set! I (+ I 1)))
    Xs))

(de (bytes:each-back Xs F)
  (let ((Len (bytes:len Xs))
        (I   (- Len 1)))
    (while (> I -1)
      (F (bytes:get Xs I) I)
      (set! I (- I 1)))
    Xs))

(de (bytes:list Xs)
  (let ((Acc nil))
    (bytes:each-back Xs (fn (X) (set! Acc (cons X Acc))))
    Acc))


;; Pair 2
;; =====================================

(de (list:reverse! Xs)
  ;; in-place
  (let ((Last nil)
        (Next nil))
    (while Xs
      (set! Next (cdr Xs))
      (set-cdr! Xs Last)
      (set! Last Xs)
      (set! Xs Next))
    Last))

(de (list:cons* X . Xs)
  ;; (cons* 1 2 3) => (1 2 . 3)
  ;; (cons* 1 2 '(3 4)) => (1 2 3 4)
  (if Xs
      (if (and (pair? (car Xs)) (not (cdr Xs)))
          (cons X (car Xs))
          (cons X (apply list:cons* Xs)))
      X))


;; String 2
;; =====================================

(de (str:chars S)
  (let ((I   0)
        (Len (str:len S))
        (Xs  (array:new Len)))
    (while (> Len I)
      (array:set! Xs I (str:get S I))
      (set! I (+ I 1)))
    Xs))
