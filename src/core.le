(def list (fn Xs Xs))

(def +   (fn (A B) (%prim:add A B)))
(def -   (fn (A B) (%prim:sub A B)))
(def *   (fn (A B) (%prim:mul A B)))
(def /   (fn (A B) (%prim:div A B)))
(def mod (fn (A B)) (%prim:mod A B))

(def =   (fn (A B) (%prim:eq A B)))
(def not (fn (x) (%prim:not x)))

(def >  (fn (A B) (%prim:gt A B)))
(def >= (fn (A B) (if (= A B) true (> A B))))
(def <  (fn (A B) (not (>= A B))))
(def <= (fn (A B) (not (> A B))))


;; Types
;; =====================================
(def type-of
     (fn (X) (%prim:type-of X)))
(def nil?     (fn (X) (not X)))
(def number?  (fn (X) (= (type-of X) 'number)))
(def array?   (fn (X) (= (type-of X) 'array)))
(def symbol?  (fn (X) (= (type-of X) 'symbol)))
(def pair?    (fn (X) (= (type-of X) 'pair)))
(def closure? (fn (X) (= (type-of X) 'closure)))
(def bytes?   (fn (X) (= (type-of X) 'bytes)))
(def string?  (fn (X) (= (type-of X) 'string)))


;; Array
;; =====================================
(def array:new  (fn (N)      (%prim:array-new N)))
(def array:get  (fn (Xs I)   (%prim:array-get Xs I)))
(def array:set! (fn (Xs I V) (%prim:array-set! Xs I V)))
(def array:len  (fn (Xs)     (%prim:array-len Xs)))


;; Pair
;; =====================================
(def cons     (fn (A B) (%prim:cons A B)))
(def car      (fn (Xs) (%prim:car Xs)))
(def cdr      (fn (Xs) (%prim:cdr Xs)))
(def set-car! (fn (Xs V) (%prim:set-car! Xs V)))
(def set-cdr! (fn (Xs V) (%prim:set-cdr! Xs V)))

(def cadr (fn (Xs) (car (cdr Xs))))
(def cddr (fn (Xs) (cdr (cdr Xs))))

(def second (fn (Xs) (car (cdr Xs))))
(def third  (fn (Xs) (car (cdr (cdr Xs)))))


;; ===== Assoc (mutable) =====

(def assoc:new
     (fn Args
       (let ((Xs Args) (Acc nil))
         (while Xs
                (set! Acc (cons (cons (car Xs) (second Xs))
                                Acc))
                (set! Xs (cddr Xs)))
         (cons '<Assoc> Acc))))

(def assoc:ref
     (fn (Assoc Key)
       (let ((Xs (cdr Assoc)) (R nil))
         (while Xs
                (let ((X (car Xs)))
                  (if (= (car X) Key)
                      (let ()
                        (set! R X)
                        (set! Xs nil))
                      (set! Xs (cdr Xs)))))
         R)))

(def assoc:get
     (fn (Assoc Key)
       (cdr (assoc:ref Assoc Key))))

(def assoc:set!
     (fn (Assoc Key Val)
       (let ((Ref (assoc:ref Assoc Key)))
         (if Ref
             (set-cdr! Ref Val)
             (set-cdr! Assoc (cons (cons Key Val)
                                   (cdr Assoc)))))
       Assoc))


;; String
;; =====================================
(def str (fn (S) (%prim:str S))) ;;TODO: concat


;; I/O
;; =====================================
(def FD-STDIN  0)
(def FD-STDOUT 1)
(def FD-STDERR 2)

(def io:getc
     (fn (FD) (%prim:getc FD)))

(def io:putc
     (fn (FD C) (%prim:putc FD C)))

(def getc
     (fn () (%prim:getc FD-STDIN)))

(def putc
     (fn (C) (%prim:putc FD-STDOUT C)))

(def c:newline 10)

(def newline
     (fn () (putc c:newline)))

(def io:print
     (fn (FD S) (%prim:print FD S)))

(def print
     (fn (X)
       (io:print FD-STDOUT
                 (if (string? X) X (str X)))
       (newline)
       X))


;; Macro System
;; =====================================

(def MACRO-TABLE ())

(def expand-macro
     (fn (Expr) Expr))

(set! %pre-eval
      (fn (Expr)
        (expand-macro Expr)))
