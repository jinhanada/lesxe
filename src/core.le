(def list (fn Xs Xs))

(def +   (fn (A B) (%prim:add A B)))
(def -   (fn (A B) (%prim:sub A B)))
(def *   (fn (A B) (%prim:mul A B)))
(def /   (fn (A B) (%prim:div A B)))
(def mod (fn (A B) (%prim:mod A B)))

(def =   (fn (A B) (%prim:eq A B)))
(def not (fn (x) (%prim:not x)))

(def >  (fn (A B) (%prim:gt A B)))
(def >= (fn (A B) (if (= A B) true (> A B))))
(def <  (fn (A B) (not (>= A B))))
(def <= (fn (A B) (not (> A B))))


;; Types
;; =====================================
(def type-of
     (fn (X) (%prim:type-of X)))
(def nil?     (fn (X) (not X)))
(def number?  (fn (X) (= (type-of X) 'number)))
(def array?   (fn (X) (= (type-of X) 'array)))
(def symbol?  (fn (X) (= (type-of X) 'symbol)))
(def pair?    (fn (X) (= (type-of X) 'pair)))
(def closure? (fn (X) (= (type-of X) 'closure)))
(def bytes?   (fn (X) (= (type-of X) 'bytes)))
(def string?  (fn (X) (= (type-of X) 'string)))

(def hash-of
     (fn (X) (%prim:hash X)))


;; Array
;; =====================================
(def array:new  (fn (N)      (%prim:array-new N)))
(def array:get  (fn (Xs I)   (%prim:array-get Xs I)))
(def array:set! (fn (Xs I V) (%prim:array-set! Xs I V)))
(def array:len  (fn (Xs)     (%prim:array-len Xs)))


;; Pair
;; =====================================
(def cons     (fn (A B) (%prim:cons A B)))
(def car      (fn (Xs) (%prim:car Xs)))
(def cdr      (fn (Xs) (%prim:cdr Xs)))
(def set-car! (fn (Xs V) (%prim:set-car! Xs V)))
(def set-cdr! (fn (Xs V) (%prim:set-cdr! Xs V)))

(def cadr (fn (Xs) (car (cdr Xs))))
(def cddr (fn (Xs) (cdr (cdr Xs))))

(def second (fn (Xs) (car (cdr Xs))))
(def third  (fn (Xs) (car (cdr (cdr Xs)))))


(def list:map
     (fn (Xs F)
       (if Xs
           (cons (F (car Xs))
                 (list:map (cdr Xs) F))
           nil)))

(def list:concat
     (fn (Xs Ys)
       (if Xs
           (cons (car Xs) (list:concat (cdr Xs) Ys))
           Ys)))


;; ===== Assoc (mutable) =====

(def assoc:sign '<Assoc>)

(def assoc:new
     (fn Args
       (let ((Xs Args) (Acc nil))
         (while Xs
                (set! Acc (cons (cons (car Xs) (second Xs))
                                Acc))
                (set! Xs (cddr Xs)))
         (cons assoc:sign Acc))))

(def assoc:ref
     (fn (Assoc Key)
       (let ((Xs (cdr Assoc)) (R nil))
         (while Xs
                (let ((X (car Xs)))
                  (if (= (car X) Key)
                      (let ()
                        (set! R X)
                        (set! Xs nil))
                      (set! Xs (cdr Xs)))))
         R)))

(def assoc:get
     (fn (Assoc Key)
       (cdr (assoc:ref Assoc Key))))

(def assoc:set!
     (fn (Assoc Key Val)
       (let ((Ref (assoc:ref Assoc Key)))
         (if Ref
             (set-cdr! Ref Val)
             (set-cdr! Assoc (cons (cons Key Val)
                                   (cdr Assoc)))))
       Assoc))


;; ===== Dict (mutable hash table) =====

(def dict:sign '<Dict>)
(def dict:default-size 63)

(def dict:aux:entry
     (fn (Dict Key)
       (let ((Xs   (second Dict))
             (Len  (array:len Xs))
             (Hash (hash-of Key))
             (I    (mod Hash Len)))
         (array:get Xs I))))

(def dict:aux:set
     (fn (Xs Len Key Val)
       (let ((Hash  (hash-of Key))
             (I     (mod Hash Len))
             (Assoc (array:get Xs I)))
         (if Assoc
             (assoc:set! Assoc Key Val)
             (array:set! Xs I (assoc:new Key Val))))))

(def dict:new
     (fn Args
       (let ((Args Args)
             (Len dict:default-size)
             (Xs (array:new Len)))
         (while Args
                (dict:aux:set Xs Len (car Args) (second Args))
                (set! Args (cddr Args)))
         (list dict:sign Xs))))

(def dict:has?
     (fn (Dict Key)
       (if (dict:aux:entry Dict Key) true nil)))

(def dict:get
     (fn (Dict Key)
       (let ((Assoc (dict:aux:entry Dict Key)))
         (assoc:get Assoc Key))))

(def dict:set!
     (fn (Dict Key Val)
       (let ((Xs (second Dict))
             (Len (array:len Xs)))
         (dict:aux:set Xs Len Key Val)
         Dict)))


;; String
;; =====================================
(def str (fn (S) (%prim:str S))) ;;TODO: concat


;; I/O
;; =====================================
(def FD-STDIN  0)
(def FD-STDOUT 1)
(def FD-STDERR 2)

(def io:getc
     (fn (FD) (%prim:getc FD)))

(def io:putc
     (fn (FD C) (%prim:putc FD C)))

(def getc
     (fn () (%prim:getc FD-STDIN)))

(def putc
     (fn (C) (%prim:putc FD-STDOUT C)))

(def c:newline 10)

(def newline
     (fn () (putc c:newline)))

(def io:print
     (fn (FD S) (%prim:print FD S)))

(def print
     (fn (X)
       (io:print FD-STDOUT
                 (if (string? X) X (str X)))
       (newline)
       X))


;; Macro System
;; =====================================

(def macro:SYNTAX-DICT (dict:new))
(def macro:MACRO-DICT (dict:new))
(def macro:DEBUG nil)

(def expand-macro-1 nil) ;; for recursion


;; ===== Syntax =====

(def macro:aux-rec
     (fn (Counter)
       (fn (Expr)
         (expand-macro-1 Counter Expr))))

(dict:set!
 macro:SYNTAX-DICT
 'let
 (fn (Counter Expr)
   (let ((Binds (car Expr))
         (Body  (cdr Expr))
         (F (macro:aux-rec Counter))
         (Binds (list:map Binds (fn (X) (list (car X) (F (second X))))))
         (Body (list:map Body F)))
     (cons 'let (cons Binds Body)))))

(dict:set!
 macro:SYNTAX-DICT
 'if
 (fn (Counter Expr)
   (let ((F    (macro:aux-rec Counter))
         (Cond (F (car Expr)))
         (Then (F (second Expr)))
         (Else (F (third Expr))))
     (list 'if Cond Then Else))))

(dict:set!
 macro:SYNTAX-DICT
 'while
 (fn (Counter Expr)
   (let ((F    (macro:aux-rec Counter))
         (Cond (F (car Expr)))
         (Body (list:map (cdr Expr) F)))
     (cons 'while (cons Cond Body)))))

(dict:set!
 macro:SYNTAX-DICT
 'set!
 (fn (Counter Expr)
   (let ((F   (macro:aux-rec Counter))
         (Var (car Expr))
         (Val (F (second Expr))))
     (list 'set! Var Val))))

(dict:set!
 macro:SYNTAX-DICT
 'fn
 (fn (Counter Expr)
   (let ((F    (macro:aux-rec Counter))
         (Vars (car Expr))
         (Body (list:map (cdr Expr) F)))
     (cons 'fn (cons Vars Body)))))

(dict:set!
 macro:SYNTAX-DICT
 'def
 (fn (Counter Expr)
   (let ((F   (macro:aux-rec Counter))
         (Var (car Expr))
         (Val (F (second Expr))))
     (list 'def Var Val))))

(dict:set!
 macro:SYNTAX-DICT
 'quote
 (fn (Counter Expr)
   (cons 'quote Expr)))

(dict:set!
 macro:SYNTAX-DICT
 'apply
 (fn (Counter Expr)
   (let ((F (macro: aux-rec Counter)))
     (list 'apply
           (F (car Expr))
           (F (second Expr))))))


;; ===== demac =====

(dict:set!
 macro:MACRO-DICT
 'demac
 (fn (Def . Body)
   ;; (demacro (Name . Args) . Body)
   ;; => (dict:set! macro:MACRO-DICT (quote . Name) (fn Args . Body))
   (let ((Name (car Def))
         (Args (cdr Def)))
     (list 'dict:set! 'macro:MACRO-DICT
           (cons 'quote Name)
           (cons 'fn (cons Args Body))))))


;; ===== expand =====

(set! expand-macro-1
      (fn (Counter Expr)
        (if (pair? Expr)
            (let ((X  (car Expr))
                  (Xs (cdr Expr))
                  (Syntax (dict:get macro:SYNTAX-DICT X))
                  (Macro  (dict:get macro:MACRO-DICT X)))
              (if Syntax
                  (Syntax Counter Xs)
                  (if Macro
                      (let ()
                        (Counter)
                        (apply Macro Xs))
                      (cons (expand-macro-1 Counter X)
                            (list:map Xs (fn (X) (expand-macro-1 Counter X)))))))
            Expr)))

(def expand-macro
     (fn (Expr)
       (let ((X Expr)
             (Count 1)
             (Counter (fn () (set! Count (+ Count 1)))))
         (while (> Count 0)
                (set! Count 0)
                (set! X (expand-macro-1 Counter X)))
         X)))

(set! %pre-eval
      (fn (Expr)
        (let ((Expanded (expand-macro Expr)))
          (if macro:DEBUG (print (list 'expanded Expanded)))
          Expanded)))


;; Macros

(demac (defn Def . Body)
  (let ((Name (car Def))
        (Args (cdr Def)))
    (list 'def
          Name
          (cons 'fn (cons Args Body)))))


(demac (and . Xs)
  (let ((rec nil))
    (set! rec
          (fn (Xs)
            (if Xs
                (list 'if (car Xs) (cons 'and (cdr Xs)) nil)
                true)))
    (rec Xs)))

(demac (or . Xs)
  (let ((rec nil))
    (set! rec
          (fn (Xs)
            (if Xs
                (list 'if (car Xs) true (cons 'or (cdr Xs)))
                nil)))
    (rec Xs)))


;; Simple quasiquote expander
;; Do not nest.
(demac (quasiquote . Expr)
  (let ((qq-object nil)
        (qq-pair nil)
        (qq-list nil))
    (set!
     qq-object
     (fn (X)
       (if (pair? X)
           (qq-list X)
           (cons 'quote X))))
    (set!
     qq-pair
     (fn (Xs)
       (if (= (car Xs) 'unquote)
           (cdr Xs)
           (qq-list Xs))))
    (set!
     qq-list
     (fn (Xs)
       (if (pair? Xs)
           (let ((F    (car Xs))
                 (Rest (cdr Xs)))
             (if (= F 'unquote)
                 ;; Xs: (unquote . Rest)
                 Rest
                 (if (and (pair? F)
                          (= (car F) 'unquote-splicing))
                     ;; Xs: ((unquote-splicing . X) . Rest)
                     (list 'list:concat (cdr F) (qq-list Rest))
                     (list 'cons (qq-object F) (qq-list Rest)))))
           (cons 'quote Xs))))
    (qq-object Expr)))


(demac (letrec Binds . Body)
  ;; (letrec ((F Fn) ...) . Body)
  ;; => (let ((F nil)) (set! F Fn) . Body)
  (let ((Defs (list:map Binds (fn (X) `(,(car X) nil))))
        (Sets (list:map Binds (fn (X) `(set! ,(car X) ,(second X))))))
    `(let ,Defs ,@Sets ,@Body)))


;; (set! macro:DEBUG true)

