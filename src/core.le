(def list (fn Xs Xs))

(def +   (fn (A B) (%prim:add A B)))
(def -   (fn (A B) (%prim:sub A B)))
(def *   (fn (A B) (%prim:mul A B)))
(def /   (fn (A B) (%prim:div A B)))
(def mod (fn (A B) (%prim:mod A B)))

(def =   (fn (A B) (%prim:eq A B)))
(def not (fn (x) (%prim:not x)))

(def >  (fn (A B) (%prim:gt A B)))
(def >= (fn (A B) (if (= A B) true (> A B))))
(def <  (fn (A B) (not (>= A B))))
(def <= (fn (A B) (not (> A B))))


;; Types
;; =====================================
(def type-of
     (fn (X) (%prim:type-of X)))
(def nil?     (fn (X) (not X)))
(def number?  (fn (X) (= (type-of X) 'number)))
(def array?   (fn (X) (= (type-of X) 'array)))
(def symbol?  (fn (X) (= (type-of X) 'symbol)))
(def pair?    (fn (X) (= (type-of X) 'pair)))
(def closure? (fn (X) (= (type-of X) 'closure)))
(def bytes?   (fn (X) (= (type-of X) 'bytes)))
(def string?  (fn (X) (= (type-of X) 'string)))

(def hash-of
     (fn (X) (%prim:hash X)))


;; Array
;; =====================================
(def array:new  (fn (N)      (%prim:array-new N)))
(def array:get  (fn (Xs I)   (%prim:array-get Xs I)))
(def array:set! (fn (Xs I V) (%prim:array-set! Xs I V)))
(def array:len  (fn (Xs)     (%prim:array-len Xs)))


;; Pair
;; =====================================
(def cons     (fn (A B) (%prim:cons A B)))
(def car      (fn (Xs) (%prim:car Xs)))
(def cdr      (fn (Xs) (%prim:cdr Xs)))
(def set-car! (fn (Xs V) (%prim:set-car! Xs V)))
(def set-cdr! (fn (Xs V) (%prim:set-cdr! Xs V)))

(def cadr (fn (Xs) (car (cdr Xs))))
(def cddr (fn (Xs) (cdr (cdr Xs))))

(def second (fn (Xs) (car (cdr Xs))))
(def third  (fn (Xs) (car (cdr (cdr Xs)))))


;; ===== Assoc (mutable) =====

(def assoc:sign '<Assoc>)

(def assoc:new
     (fn Args
       (let ((Xs Args) (Acc nil))
         (while Xs
                (set! Acc (cons (cons (car Xs) (second Xs))
                                Acc))
                (set! Xs (cddr Xs)))
         (cons assoc:sign Acc))))

(def assoc:ref
     (fn (Assoc Key)
       (let ((Xs (cdr Assoc)) (R nil))
         (while Xs
                (let ((X (car Xs)))
                  (if (= (car X) Key)
                      (let ()
                        (set! R X)
                        (set! Xs nil))
                      (set! Xs (cdr Xs)))))
         R)))

(def assoc:get
     (fn (Assoc Key)
       (cdr (assoc:ref Assoc Key))))

(def assoc:set!
     (fn (Assoc Key Val)
       (let ((Ref (assoc:ref Assoc Key)))
         (if Ref
             (set-cdr! Ref Val)
             (set-cdr! Assoc (cons (cons Key Val)
                                   (cdr Assoc)))))
       Assoc))


;; ===== Dict (mutable hash table) =====

(def dict:sign '<Dict>)
(def dict:default-size 63)

(def dict:aux:entry
     (fn (Dict Key)
       (let ((Xs   (second Dict))
             (Len  (array:len Xs))
             (Hash (hash-of Key))
             (I    (mod Hash Len)))
         (array:get Xs I))))

(def dict:aux:set
     (fn (Xs Len Key Val)
       (let ((Hash  (hash-of Key))
             (I     (mod Hash Len))
             (Assoc (array:get Xs I)))
         (if Assoc
             (assoc:set! Assoc Key Val)
             (array:set! Xs I (assoc:new Key Val))))))

(def dict:new
     (fn Args
       (let ((Args Args)
             (Len dict:default-size)
             (Xs (array:new Len)))
         (while Args
                (dict:aux:set Xs Len (car Args) (second Args))
                (set! Args (cddr Args)))
         (list dict:sign Xs))))

(def dict:has?
     (fn (Dict Key)
       (if (dict:aux:entry Dict Key) true nil)))

(def dict:get
     (fn (Dict Key)
       (let ((Assoc (dict:aux:entry Dict Key)))
         (assoc:get Assoc Key))))

(def dict:set!
     (fn (Dict Key Val)
       (let ((Xs (second Dict))
             (Len (array:len Xs)))
         (dict:aux:set Xs Len Key Val)
         Dict)))


;; String
;; =====================================
(def str (fn (S) (%prim:str S))) ;;TODO: concat


;; I/O
;; =====================================
(def FD-STDIN  0)
(def FD-STDOUT 1)
(def FD-STDERR 2)

(def io:getc
     (fn (FD) (%prim:getc FD)))

(def io:putc
     (fn (FD C) (%prim:putc FD C)))

(def getc
     (fn () (%prim:getc FD-STDIN)))

(def putc
     (fn (C) (%prim:putc FD-STDOUT C)))

(def c:newline 10)

(def newline
     (fn () (putc c:newline)))

(def io:print
     (fn (FD S) (%prim:print FD S)))

(def print
     (fn (X)
       (io:print FD-STDOUT
                 (if (string? X) X (str X)))
       (newline)
       X))


;; Macro System
;; =====================================

(def MACRO-TABLE (dict:new))

(def expand-macro-1
     (fn (Expr Counter) Expr))

(def expand-macro
     (fn (Expr)
       (let ((X Expr)
             (Count 1)
             (Counter (fn () (set! Count (+ Count 1)))))
         (while (> Count 0)
                (set! Count 0)
                (set! X (expand-macro-1 X Counter)))
         X)))

(set! %pre-eval
      (fn (Expr)
        (expand-macro Expr)))
