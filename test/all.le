(demac (test Name . Body)
  `(catch
    (let ()
      (prin1 (str 'test " " ',Name " ... "))
      ,@Body
      (print 'ok))
    (fn (E) (print (list 'test 'failed ',Name E)))))

(de (assert Cond)
  (or Cond (raise 'assert)))

(demac (assert= A B)
  `(let ((X ,A)
         (Y ,B))
     (or (= X Y)
         (raise (list 'assert= '(,A ,B) 'but 'got (list X Y))))))


(test letrec
  ;; single recursion
  (assert
   (= 11
      (letrec ((F (fn (X)
                    (if (> X 10)
                      X
                      (F (+ X 1))))))
        (F 0))))
  
  ;; mutual recursion
  (assert
   (= 11
      (letrec ((F (fn (X) (if (> X 10) X (G (+ X 1)))))
               (G (fn (X) (if (> X 10) X (F (+ X 1))))))
       (F 0)))))


(test record-case
  (assert=
   'a
   (record-case '(foo a b)
     ((foo A B) A)
     (else      'b)))

  (assert=
   'b
   (record-case '(bar a b)
     ((foo A B) A)
     (else      'b)))

  (assert=
   'x
   (catch
    (record-case '(bar a b)
      ((foo A B) A))
    (fn (_) 'x))))


(test cond
  (letrec
      ((F
        (fn (N)
          (cond
           ((= N 1) 'a)
           ((= N 2) 'b)
           (else    'c)))))
    (assert= 'a (F 1))
    (assert= 'b (F 2))
    (assert= 'c (F 3))))


(test threading-macro
  (assert= 2 (-> 1 inc))
  (assert= 1 (-> 3 (- 2)))
  (assert= 3 (-> 1 (+ 2) (- 2) inc inc)))
